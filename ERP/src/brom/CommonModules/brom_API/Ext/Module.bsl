#Область Генерация_объектов_Бром
Функция СоздатьXDTOОбъект(типДанных) Экспорт
	типДанных = brom_API_ПИ.ТипДанныхXDTO(типДанных);
	Возврат ФабрикаXDTO.Создать(типДанных);
КонецФункции
#КонецОбласти

#Область Упаковка_и_распаковка_значений
Функция ВЗначениеБром(значение, представление = Неопределено) Экспорт
	типОбъекта 		= ТипЗнч(значение);
	
	Если типОбъекта 		= Тип("Неопределено") Тогда
		Возврат СоздатьXDTOОбъект("ValueNull");	
	ИначеЕсли типОбъекта 	= Тип("Null") Тогда
		Возврат СоздатьXDTOОбъект("ValueDBNull");
	ИначеЕсли типОбъекта 	= Тип("Строка") Тогда
		Возврат ВЗначениеБром_ПростойТип(значение, "ValueString");
	ИначеЕсли типОбъекта 	= Тип("Число") Тогда
		Возврат ВЗначениеБром_ПростойТип(значение, "ValueNumber");
	ИначеЕсли типОбъекта 	= Тип("Булево") Тогда
		Возврат ВЗначениеБром_ПростойТип(значение, "ValueBoolean");
	ИначеЕсли типОбъекта 	= Тип("Дата") Тогда
		Возврат ВЗначениеБром_ПростойТип(значение, "ValueDate");
	ИначеЕсли типОбъекта 	= Тип("УникальныйИдентификатор") Тогда
		Возврат ВЗначениеБром_УникальныйИдентификатор(значение);
	ИначеЕсли типОбъекта 	= Тип("МоментВремени") Тогда
		Возврат ВЗначениеБром_МоментВремени(значение);
	ИначеЕсли типОбъекта 	= Тип("Граница") Тогда
		Возврат ВЗначениеБром_Граница(значение);
	ИначеЕсли типОбъекта 	= Тип("Тип") Тогда
		Возврат ВЗначениеБром_Тип(значение);
	ИначеЕсли типОбъекта 	= Тип("ОписаниеТипов") Тогда
		Возврат ВЗначениеБром_ОписаниеТипов(значение);
	ИначеЕсли типОбъекта 	= Тип("Массив") Тогда
		Возврат ВЗначениеБром_Массив(значение);
	ИначеЕсли типОбъекта 	= Тип("Структура") Тогда
		Возврат ВЗначениеБром_Структура(значение);
	ИначеЕсли типОбъекта 	= Тип("Соответствие") Тогда
		Возврат ВЗначениеБром_Соответствие(значение);
	ИначеЕсли типОбъекта 	= Тип("ТаблицаЗначений") Тогда
		Возврат ВЗначениеБром_ТаблицаЗначений(значение);
	ИначеЕсли типОбъекта 	= Тип("ДеревоЗначений") Тогда
		Возврат ВЗначениеБром_ДеревоЗначений(значение);
	ИначеЕсли типОбъекта 	= Тип("ДвоичныеДанные") Тогда
		Возврат ВЗначениеБром_ДвоичныеДанные(значение);
	ИначеЕсли типОбъекта 	= Тип("ХранилищеЗначения") Тогда
		Возврат ВЗначениеБром_ХранилищеЗначения(значение);
	ИначеЕсли типОбъекта 	= Тип("КлючИЗначение") Тогда
		Возврат ВЗначениеБром_КлючИЗначение(значение);
	КонецЕсли;
	
	xmlТипОбъекта = XMLТип(типОбъекта);
	Если xmlТипОбъекта <> Неопределено Тогда
		Если brom_Метаданные_ПИ.ЭтоСсылочныйТип(xmlТипОбъекта.ИмяТипа) Тогда
			имяМетаданных = значение.Метаданные().ПолноеИмя();
			Если brom_Метаданные_ПИ.ЭтоПеречисление(имяМетаданных) Тогда
				Возврат ВЗначениеБром_ПеречислениеСсылка(значение);	
			Иначе
				Возврат ВЗначениеБром_ОбъектСсылка(значение, представление);
			КонецЕсли;
		ИначеЕсли brom_Метаданные_ПИ.ЭтоСистемноеПеречисление(xmlТипОбъекта.ИмяТипа) Тогда
			Возврат ВЗначениеБром_СистемноеПеречисление(значение);	
		КонецЕсли;
	КонецЕсли;
	
	Возврат СоздатьXDTOОбъект("ValueNonserializable");
КонецФункции
Функция ВЗначениеБром_ПростойТип(значение, xdtoТип)
	xdtoОбъект = СоздатьXDTOОбъект(xdtoТип);
	xdtoОбъект.Value = значение;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_УникальныйИдентификатор(значение)
	xdtoОбъект = СоздатьXDTOОбъект("ValueGuid");
	xdtoОбъект.Value = Строка(значение);
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_МоментВремени(значение)
	xdtoОбъект 		= СоздатьXDTOОбъект("ValuePointInTime");
	xdtoОбъект.Date = значение.Дата;
	xdtoОбъект.Ref	= ВЗначениеБром(значение.Ссылка);
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_Граница(значение)
	xdtoОбъект 			= СоздатьXDTOОбъект("ValueBoundary");
	xdtoОбъект.Value 	= ВЗначениеБром(значение.Значение);
	xdtoОбъект.Type		= Строка(значение.ВидГраницы);
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_Тип(значение)
	xdtoОбъект 				= СоздатьXDTOОбъект("ValueType");
	xmlТип					= XMLТип(значение);
	xdtoОбъект.Value 		= xmlТип.ИмяТипа;
	xdtoОбъект.Namespace	= xmlТип.URIПространстваИмен;
	Если xdtoОбъект.Namespace = "http://www.w3.org/2001/XMLSchema" Тогда
		xdtoОбъект.Namespace = "#xs";
	ИначеЕсли xdtoОбъект.Namespace = "http://v8.1c.ru/data" Тогда
		xdtoОбъект.Namespace = "#1c";
	КонецЕсли;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_ОписаниеТипов(значение)
	xdtoОбъект 		= СоздатьXDTOОбъект("ValueTypeDescription");
	типы 			= значение.Типы();
	
	Для Каждого тип Из типы Цикл
		xdtoОбъект.Item.Добавить(ВЗначениеБром_Тип(тип));
	КонецЦикла;
	
	xdtoОбъект.NumberQualifiers = Неопределено;
	Если значение.КвалификаторыЧисла <> Неопределено Тогда
		xdtoОбъект.NumberQualifiers 				= СоздатьXDTOОбъект("NumberQualifiers");
		xdtoОбъект.NumberQualifiers.Digits 			= значение.КвалификаторыЧисла.Разрядность;
		xdtoОбъект.NumberQualifiers.FractionDigits 	= значение.КвалификаторыЧисла.РазрядностьДробнойЧасти;
		xdtoОбъект.NumberQualifiers.OnlyPositive 	= (значение.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный);
	КонецЕсли;
	
	xdtoОбъект.StringQualifiers = Неопределено;
	Если значение.КвалификаторыСтроки <> Неопределено Тогда
		xdtoОбъект.StringQualifiers 				= СоздатьXDTOОбъект("StringQualifiers");
		xdtoОбъект.StringQualifiers.Length 			= значение.КвалификаторыСтроки.Длина;
		xdtoОбъект.StringQualifiers.AllowedLength 	= XMLСтрока(значение.КвалификаторыСтроки.ДопустимаяДлина);
	КонецЕсли;
	
	xdtoОбъект.DateQualifiers = Неопределено;
	Если значение.КвалификаторыДаты <> Неопределено Тогда
		xdtoОбъект.DateQualifiers 					= СоздатьXDTOОбъект("DateQualifiers");
		xdtoОбъект.DateQualifiers.DateFractions 	= XMLСтрока(значение.КвалификаторыДаты.ЧастиДаты);
	КонецЕсли;
	
	xdtoОбъект.BinaryDataQualifiers = Неопределено;
	Если значение.КвалификаторыДвоичныхДанных <> Неопределено Тогда
		xdtoОбъект.BinaryDataQualifiers 				= СоздатьXDTOОбъект("BinaryDataQualifiers");
		xdtoОбъект.BinaryDataQualifiers.Length 			= значение.КвалификаторыДвоичныхДанных.Длина;
		xdtoОбъект.BinaryDataQualifiers.AllowedLength 	= XMLСтрока(значение.КвалификаторыДвоичныхДанных.ДопустимаяДлина);
	КонецЕсли;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_ДвоичныеДанные(значение)
	xdtoОбъект 		= СоздатьXDTOОбъект("ValueBinaryData");
	xdtoОбъект.Value = значение;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_ХранилищеЗначения(значение)
	xdtoОбъект 			= СоздатьXDTOОбъект("ValueStorage");
	xdtoОбъект.Data 	= ВЗначениеБром(значение.Получить());
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_КлючИЗначение(значение)
	xdtoОбъект 			= СоздатьXDTOОбъект("ValueKeyValue");
	xdtoОбъект.Key 		= ВЗначениеБром(значение.Ключ);
	xdtoОбъект.Value	= ВЗначениеБром(значение.Значение);
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_ПеречислениеСсылка(значение)
	текМетаданные = значение.Метаданные();
	имяМетаданных = текМетаданные.ПолноеИмя();
	менеджер = brom_Метаданные_ПИ.ПолучитьМенеджер(имяМетаданных);
	
	xdtoОбъект 				= СоздатьXDTOОбъект("ValueEnumRef");
	xdtoОбъект.Type 		= имяМетаданных;
	xdtoОбъект.Value 		= ?(ЗначениеЗаполнено(значение), текМетаданные.ЗначенияПеречисления[менеджер.Индекс(значение)].Имя, Неопределено);
	xdtoОбъект.Presentation = Строка(значение);
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_ОбъектСсылка(значение, представление = Неопределено)
	имяМетаданных =  значение.Метаданные().ПолноеИмя();
	
	xdtoОбъект 					= СоздатьXDTOОбъект("ValueObjectRef");
	xdtoОбъект.Type 			= имяМетаданных;
	xdtoОбъект.Value 			= Строка(значение.УникальныйИдентификатор());
	Если ЗначениеЗаполнено(представление) Тогда
		xdtoОбъект.Presentation 	= представление;	
	КонецЕсли;
	
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_СистемноеПеречисление(значение)
	типЗнч = ТипЗнч(значение);
	
	Если 		типЗнч = Тип("ВидДвиженияБухгалтерии") Тогда
		xdtoОбъект = СоздатьXDTOОбъект("ValueAccountingRecordType");
	ИначеЕсли 	типЗнч = Тип("ВидДвиженияНакопления") Тогда
		xdtoОбъект = СоздатьXDTOОбъект("ValueAccumulationRecordType");
	ИначеЕсли 	типЗнч = Тип("ВидСчета") Тогда
		xdtoОбъект = СоздатьXDTOОбъект("ValueAccountType");
	ИначеЕсли 	типЗнч = Тип("РежимЗаписиДокумента") Тогда
		xdtoОбъект = СоздатьXDTOОбъект("ValueDocumentWriteMode");
	ИначеЕсли 	типЗнч = Тип("РежимПроведенияДокумента") Тогда
		xdtoОбъект = СоздатьXDTOОбъект("ValueDocumentPostingMode");
	КонецЕсли;
	
	xdtoОбъект.Value = XMLСтрока(значение);	
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_Массив(значения)
	xdtoОбъект = СоздатьXDTOОбъект("ValueArray");
	
	Для Каждого значение Из значения Цикл
		xdtoОбъект.Item.Добавить(ВЗначениеБром(значение));
	КонецЦикла;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_Структура(текСтруктура)	
	xdtoОбъект 			= СоздатьXDTOОбъект("ValueStruct");	
	
	Для Каждого ключЗначение Из текСтруктура Цикл
		свойство 		= ВЗначениеБром(ключЗначение.Значение);
		свойство.Name 	= ключЗначение.Ключ;
		xdtoОбъект.Property.Добавить(свойство);
	КонецЦикла;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_Соответствие(текСтруктура)	
	xdtoОбъект 			= СоздатьXDTOОбъект("ValueMap");	
	
	Для Каждого ключЗначение Из текСтруктура Цикл
		xdtoКлючЗначение		= СоздатьXDTOОбъект("ValueKeyValue");
		
		xdtoКлючЗначение.Key 	= ВЗначениеБром(ключЗначение.Ключ);
		xdtoКлючЗначение.Value 	= ВЗначениеБром(ключЗначение.Значение);
		xdtoОбъект.KeyValue.Add(xdtoКлючЗначение); 
	КонецЦикла;
	
	Возврат xdtoОбъект;
КонецФункции
Функция ВЗначениеБром_ТаблицаЗначений(данные)
	результат 		= СоздатьXDTOОбъект("ValueTable");
			
	Для Каждого колонка Из данные.Колонки Цикл
		столбец = СоздатьXDTOОбъект("DataTableColumn");
		столбец.Name = колонка.Имя;
		результат.Column.Добавить(столбец);
	КонецЦикла;
	
	иерархияПолей = ПолучитьИерархиюПолейЗапросаИзТаблицы(данные);
	Для Каждого стр Из данные Цикл
		xdtoRow	= СоздатьXDTOОбъект("DataTableRow");
	
		ЗаполнитьСвойстваСущности(xdtoRow, стр, иерархияПолей);		
		результат.Row.Добавить(xdtoRow);
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Функция ВЗначениеБром_ДеревоЗначений(данные)
	результат 		= СоздатьXDTOОбъект("ValueTree");
				
	Для Каждого колонка Из данные.Колонки Цикл
		столбец = СоздатьXDTOОбъект("DataTableColumn");
		столбец.Name = колонка.Имя;
		результат.Column.Добавить(столбец);
	КонецЦикла;
	
	иерархияПолей = ПолучитьИерархиюПолейЗапросаИзТаблицы(данные);
	Для Каждого стр Из данные.Строки Цикл
		ВЗначениеБром_ДеревоЗначений_ДобавитьСроку(результат, стр, иерархияПолей);
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Процедура ВЗначениеБром_ДеревоЗначений_ДобавитьСроку(объектРодитель, данныеСтроки, иерархияПолей)
	результат 		= СоздатьXDTOОбъект("DataTableRow");
	
	ЗаполнитьСвойстваСущности(результат, данныеСтроки, иерархияПолей);		
	объектРодитель.Row.Добавить(результат);
	
	Для Каждого стр Из данныеСтроки.Строки Цикл
		ВЗначениеБром_ДеревоЗначений_ДобавитьСроку(результат, стр, иерархияПолей);	
	КонецЦикла;
КонецПроцедуры
Функция ВЗначениеБром_ИзПоляДанных(данные, имяПоля)	
	значение = данные[имяПоля];
	
	значениеXDTO 	= ВЗначениеБром(значение);
	
	Если значениеXDTO.Свойства().Получить("Presentation") <> Неопределено Тогда
		имяПоляПредставления = имяПоля + "Представление";
		структДанные = Новый Структура(имяПоля+", " + имяПоляПредставления);
		ЗаполнитьЗначенияСвойств(структДанные, данные);
		
		представление = структДанные[имяПоляПредставления];
		представление = ?(представление = NULL, "", представление);
		
		Если представление <> Неопределено Тогда
			значениеXDTO.Presentation = представление;	
		КонецЕсли;
	КонецЕсли;	
	
	Возврат значениеXDTO;
КонецФункции
Процедура ЗаполнитьСвойстваСущности(объект, данные, иерархияПолей)
	Если иерархияПолей = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если объект.Свойства().Получить("Property") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого данныеПоля Из иерархияПолей.ПоляМассивом Цикл		
		свойство 		= ВЗначениеБром_ИзПоляДанных(данные, данныеПоля.ГлобальноеИмя);
		свойство.Name 	= данныеПоля.ЛокальноеИмя;
		
		объект.Property.Добавить(свойство);
		
		ЗаполнитьСвойстваСущности(свойство, данные, данныеПоля);
	КонецЦикла;
КонецПроцедуры


Функция ИзЗначенияБром(значение) Экспорт
	Если значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	типЗначения = ТипЗнч(значение);
	
	Если типЗначения <> Тип("ОбъектXDTO") Тогда
		ВызватьИсключение "Передан не верный тип значения. Значение должно иметь тип ""ОбъектXDTO"" или ""Неопределено"".";
	КонецЕсли;
	Если значение.Тип().URIПространстваИмен <> brom_API_ПИ.ПространствоИменБром() Тогда
		ВызватьИсключение "Переданный объект XDTO не пренадлежит пространству имен """ + brom_API_ПИ.ПространствоИменБром() + """.";
	КонецЕсли;
	
	простойТип = brom_API_ПИ.ТипДанныхXDTO("ValueSimple");
	
	типXDTO = значение.Тип();
	имяТипаXDTO = типXDTO.Имя; 
	
	Если 		имяТипаXDTO = "ValueNull" Тогда
		Возврат Неопределено;		
	ИначеЕсли 	имяТипаXDTO = "ValueDBNull" Тогда
		Возврат Null;	
	ИначеЕсли brom_Утилиты.СравнитьТипыXDTO(значение.Тип().БазовыйТип, простойТип) Тогда
		Возврат значение.Value;
	ИначеЕсли 	имяТипаXDTO = "ValueGuid" Тогда
		Возврат Новый УникальныйИдентификатор(значение.Value);
	ИначеЕсли 	имяТипаXDTO = "ValuePointInTime" Тогда
		Возврат Новый МоментВремени(значение.Date, ИзЗначенияБром(значение.Ref));
	ИначеЕсли 	имяТипаXDTO = "ValueBoundary" Тогда
		Возврат Новый Граница(ИзЗначенияБром(значение.Value), ВидГраницы[значение.Type]);
	ИначеЕсли 	имяТипаXDTO = "ValueArray" Тогда
		Возврат ИзЗначенияБром_Массив(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueStruct" Тогда
		Возврат ИзЗначенияБром_Структура(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueMap" Тогда
		Возврат ИзЗначенияБром_Соответствие(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueTable" Тогда
		Возврат ИзЗначенияБром_ТаблицаЗначений(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueTree" Тогда
		Возврат ИзЗначенияБром_ДеревоЗначений(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueKeyValue" Тогда
		Возврат ИзЗначенияБром_КлючИЗначение(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueBinaryData" Тогда
		Возврат значение.Value;
	ИначеЕсли 	имяТипаXDTO = "ValueStorage" Тогда
		Возврат Новый ХранилищеЗначения(ИзЗначенияБром(значение.Data));
	ИначеЕсли 	имяТипаXDTO = "ValueEnumRef" Тогда
		Возврат ИзЗначенияБром_ПеречислениеСсылка(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueType" Тогда
		Возврат ИзЗначенияБром_Тип(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueTypeDescription" Тогда
		Возврат ИзЗначенияБром_ОписаниеТипа(значение);
	ИначеЕсли 	имяТипаXDTO = "ValueObjectRef" Тогда
		Возврат ИзЗначенияБром_ОбъектСсылка(значение);
	ИначеЕсли значение.Тип().БазовыйТип = brom_API_ПИ.ТипДанныхXDTO("ValueSystemEnum") Тогда
		Возврат ИзЗначенияБром_СистемноеПеречисление(значение);
	КонецЕсли;
	
	ВызватьИсключение "Не удалось десериализовать значение типа """ + имяТипаXDTO + """.";       
КонецФункции
Функция ИзЗначенияБром_ПеречислениеСсылка(значение)
	менеджер = brom_Метаданные_ПИ.ПолучитьМенеджер(значение.Type);
	
	Возврат ?(ЗначениеЗаполнено(значение.Value), менеджер[значение.Value], менеджер.ПустаяСсылка());
КонецФункции
Функция ИзЗначенияБром_ОбъектСсылка(значение)
	менеджер = brom_Метаданные_ПИ.ПолучитьМенеджер(значение.Type);
	
	Возврат менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(значение.Value));
КонецФункции
Функция ИзЗначенияБром_Тип(значение)
	пространствоИмен = значение.Namespace;
	Если пространствоИмен = "#xs" Тогда
		пространствоИмен = "http://www.w3.org/2001/XMLSchema";
	ИначеЕсли пространствоИмен = "#1c" Тогда
		пространствоИмен = "http://v8.1c.ru/data";
	КонецЕсли;
	
	Возврат ИзXMLТипа(значение.Value, пространствоИмен);
КонецФункции
Функция ИзЗначенияБром_ОписаниеТипа(значение)
	массивТипов = Новый Массив();
	Для Каждого элемент Из значение.Item Цикл
		массивТипов.Добавить(ИзЗначенияБром_Тип(элемент));
	КонецЦикла;
	
	квалЧисла = Неопределено;
	Если значение.NumberQualifiers <> Неопределено Тогда
		квалЧисла = Новый КвалификаторыЧисла(значение.NumberQualifiers.Digits, значение.NumberQualifiers.FractionDigits, ?(значение.NumberQualifiers.OnlyPositive = Истина, ДопустимыйЗнак.Неотрицательный, ДопустимыйЗнак.Любой)); 
	КонецЕсли;
	
	квалСтроки = Неопределено;
	Если значение.StringQualifiers <> Неопределено Тогда
		квалСтроки = Новый КвалификаторыСтроки(значение.StringQualifiers.Length, ДопустимаяДлина[значение.StringQualifiers.AllowedLength]); 
	КонецЕсли;
	
	квалДаты = Неопределено;
	Если значение.DateQualifiers <> Неопределено Тогда
		квалДаты = Новый КвалификаторыДаты(ЧастиДаты[значение.DateQualifiers.DateFractions]); 
	КонецЕсли;	
	
	квалДвоичДанных = Неопределено;
	Если значение.BinaryDataQualifiers <> Неопределено Тогда
		квалДвоичДанных = Новый КвалификаторыДвоичныхДанных(значение.BinaryDataQualifiers.Length, ДопустимаяДлина[значение.BinaryDataQualifiers.AllowedLength]); 
	КонецЕсли;
		
	
	Возврат Новый ОписаниеТипов(
		массивТипов,
		квалЧисла,
		квалСтроки,
		квалДаты,
		квалДвоичДанных
	);
КонецФункции
Функция ИзЗначенияБром_СистемноеПеречисление(значение)
	имяТипа = значение.Тип().Имя;
	
	Если имяТипа = "ValueAccountingRecordType" Тогда
		систПеречисление = ВидДвиженияБухгалтерии;
	ИначеЕсли имяТипа = "ValueAccumulationRecordType" Тогда
		систПеречисление = ВидДвиженияНакопления;
	ИначеЕсли имяТипа = "ValueCalculationRegisterPeriodType" Тогда
		систПеречисление = ВидПериодаРегистраРасчета;
	ИначеЕсли имяТипа = "ValueAccountType" Тогда
		систПеречисление = ВидСчета;
	ИначеЕсли имяТипа = "ValueBusinessProcessRoutePointType" Тогда
		систПеречисление = ВидТочкиМаршрутаБизнесПроцесса;
	ИначеЕсли имяТипа = "ValueDocumentWriteMode" Тогда
		систПеречисление = РежимЗаписиДокумента;
	ИначеЕсли имяТипа = "ValueDocumentPostingMode" Тогда
		систПеречисление = РежимПроведенияДокумента;
	КонецЕсли;
	
	Возврат систПеречисление[значение.Value];
КонецФункции
Функция ИзЗначенияБром_Массив(значение)
	результат = Новый Массив();
	Для Каждого текЭлемент Из значение.Item Цикл
		результат.Добавить(ИзЗначенияБром(текЭлемент));
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Функция ИзЗначенияБром_Структура(текЗнач)
	результат = Новый Структура();
	
	Для Каждого текСвойство Из текЗнач.Property Цикл
		результат.Вставить(текСвойство.Name, ИзЗначенияБром(текСвойство));
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Функция ИзЗначенияБром_Соответствие(текЗнач)
	результат = Новый Соответствие();
	
	Для Каждого ключЗначение Из текЗнач.KeyValue Цикл
		результат.Вставить(ИзЗначенияБром(ключЗначение.Key), ИзЗначенияБром(ключЗначение.Value));
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Функция ИзЗначенияБром_ТаблицаЗначений(текЗнач)
	текТаблица = Новый ТаблицаЗначений();
	
	Для Каждого колонка Из текЗнач.Column Цикл
		текТаблица.Колонки.Добавить(колонка.Name);
	КонецЦикла;
	
	Для Каждого стр Из текЗнач.Row Цикл
		данные = ИзЗначенияБром_Структура(стр);
		
		новСтр = текТаблица.Добавить();
		ЗаполнитьЗначенияСвойств(новСтр, данные);
	КонецЦикла;
	
	Возврат текТаблица;
КонецФункции
Функция ИзЗначенияБром_ДеревоЗначений(текЗнач)
	текДерево = Новый ДеревоЗначений();
	
	Для Каждого колонка Из текЗнач.Column Цикл
		текДерево.Колонки.Добавить(колонка.Name);
	КонецЦикла;

	ИзЗначенияБром_ДеревоЗначений_ЗаполнитьСтрокиДерева(текДерево, текЗнач.Row);
		  	
	Возврат текДерево;
КонецФункции
Функция ИзЗначенияБром_ДеревоЗначений_ЗаполнитьСтрокиДерева(узелДерева, строки)
	Для Каждого стр Из строки Цикл
		данные = ИзЗначенияБром_Структура(стр);
		
		новСтр = узелДерева.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(новСтр, данные);
		
		ИзЗначенияБром_ДеревоЗначений_ЗаполнитьСтрокиДерева(новСтр, стр.Row);
	КонецЦикла;
КонецФункции
Функция ИзЗначенияБром_КлючИЗначение(текЗнач)
	текСоответствие = Новый Соответствие();
	текСоответствие.Вставить(ИзЗначенияБром(текЗнач.Key), ИзЗначенияБром(текЗнач.Value));
	
	Для Каждого текКлючЗначение Из текСоответствие Цикл
		Возврат текКлючЗначение;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции
#КонецОбласти

#Область Работа_с_построителем_запроса
Процедура ПрименитьНастройкиЗапроса(построитель, настройкиВыполнения, префиксКлюча = "")
	Если настройкиВыполнения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПрименитьФильтрЗапроса(построитель, настройкиВыполнения, префиксКлюча);
	ПрименитьСортировкуЗапроса(построитель, настройкиВыполнения, префиксКлюча);
	ПрименитьПоляЗапроса(построитель, настройкиВыполнения, префиксКлюча);
	ПрименитьПараметрыЗапроса(построитель, настройкиВыполнения);
КонецПроцедуры
Процедура ПрименитьФильтрЗапроса(построитель, настройкиВыполнения, префиксКлюча = "")
	xdtoFilters = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиВыполнения.НастройкиЗапроса, "Filter");
	Если xdtoFilters = Неопределено Тогда
		Возврат;
	КонецЕсли;	
	
	к = 1;
	Для Каждого условие Из настройкиВыполнения.НастройкиЗапроса.Filter Цикл
		ключ = ?(ЗначениеЗаполнено(префиксКлюча), префиксКлюча + "." + условие.Key, условие.Key);
		
		значение = ПолучитьЗначениеСравненияФильтра(условие);
		                                                                          
		элемент = построитель.Отбор.Добавить(ключ, "Условие_" + Формат(к, "ЧН=0; ЧГ=0"));
		элемент.ВидСравнения 	= ПолучитьВидСравнения(условие, значение);
		элемент.Значение		= значение;
		элемент.Использование	= Истина;
		к = к + 1;
	КонецЦикла;
КонецПроцедуры
Процедура ПрименитьПараметрыЗапроса(построитель, настройкиВыполнения, префиксКлюча = "")
	xdtoParameters = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиВыполнения.НастройкиЗапроса, "Parameter");
	Если xdtoParameters = Неопределено Тогда
		Возврат;
	КонецЕсли;	
	
	Для Каждого параметр Из xdtoParameters Цикл
		построитель.Параметры.Вставить(параметр.Key, ИзЗначенияБром(параметр.Value));
	КонецЦикла;
КонецПроцедуры
Процедура ПрименитьСортировкуЗапроса(построитель, настройкиВыполнения, префиксКлюча = "")
	xdtoSort = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиВыполнения.НастройкиЗапроса, "Sort");
	Если xdtoSort = Неопределено Тогда
		Возврат;
	КонецЕсли;	
	
	к = 1;
	Для Каждого сортировка Из настройкиВыполнения.НастройкиЗапроса.Sort Цикл
		ключ = ?(ЗначениеЗаполнено(префиксКлюча), префиксКлюча + "." + сортировка.Key, сортировка.Key);
		
		направление = НаправлениеСортировки[сортировка.Direction];
		построитель.Порядок.Добавить(ключ, "Сортировка_" + Формат(к, "ЧН=0; ЧГ=0"), , направление);
		к = к + 1;
	КонецЦикла;
КонецПроцедуры
Процедура ПрименитьПоляЗапроса(построитель, настройкиВыполнения, префиксКлюча = "")
	Если настройкиВыполнения.ИерархияПолей = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПрименитьПолеЗапроса(построитель, настройкиВыполнения.ИерархияПолей, префиксКлюча);
КонецПроцедуры
Процедура ПрименитьПолеЗапроса(построитель, данныеПоля, префиксКлюча = "")
	Если ЗначениеЗаполнено(данныеПоля.Путь) Тогда
		ключ = ?(ЗначениеЗаполнено(префиксКлюча), префиксКлюча + "." + данныеПоля.Путь, данныеПоля.Путь);
		имяПоля = данныеПоля.ГлобальноеИмя;
		построитель.ВыбранныеПоля.Вставить(ключ, имяПоля, 0); 
	КонецЕсли;
	
	Для Каждого ключЗначение Из данныеПоля.Поля Цикл
		текДанные = ключЗначение.Значение;
		ПрименитьПолеЗапроса(построитель, текДанные, префиксКлюча);
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьВидСравнения(условие, значение)
	текВидСравнения = ВидСравнения[условие.ComparisonType];
	Если текВидСравнения = ВидСравнения.ВИерархии И ТипЗнч(значение) = Тип("СписокЗначений") Тогда
		Возврат ВидСравнения.ВСпискеПоИерархии;
	КонецЕсли;
	Если текВидСравнения = ВидСравнения.НеВИерархии И ТипЗнч(значение) = Тип("СписокЗначений") Тогда
		Возврат ВидСравнения.НеВСпискеПоИерархии;
	КонецЕсли;
	
	Возврат ВидСравнения[условие.ComparisonType];
КонецФункции
Функция ПолучитьЗначениеСравненияФильтра(условие)
	значение = ИзЗначенияБром(условие.Value);
	
	Если ТипЗнч(значение) = Тип("Массив") Тогда
		список = Новый СписокЗначений();
		список.ЗагрузитьЗначения(значение);
		значение = список;
	КонецЕсли;
	
	Возврат значение;
КонецФункции
#КонецОбласти

#Область Получение_настроек_выполнения
Функция ПолучитьНастройкиВыполнения(настройкиЗапроса, имяМетаданных = "")
	настройкиВыполнения = Новый Структура();
	настройкиВыполнения.Вставить("НастройкиЗапроса", 				настройкиЗапроса);
		
	настройкиВыполнения.Вставить("ТипИерархииСвойств", 				ПолучитьТипИерархииСвойствИзНастроек(настройкиЗапроса));
	настройкиВыполнения.Вставить("ДобавлятьПропущенныеПоля", 		brom_Утилиты.СвйоствоОбъектаXDTO(настройкиЗапроса, "AddSkippedProperties", Ложь));	
	настройкиВыполнения.Вставить("ТипОбходаРезультатаЗапроса", 		ОбходРезультатаЗапроса[brom_Утилиты.СвйоствоОбъектаXDTO(настройкиЗапроса, "QueryResultIteration", "Прямой")]);
	настройкиВыполнения.Вставить("АвтодобавлениеПолей", 			ПолучитьНастройкиАвтодобавленияПолей(настройкиЗапроса));
	настройкиВыполнения.Вставить("ВключениеПромежуточныхДанных",	brom_Утилиты.СвйоствоОбъектаXDTO(настройкиЗапроса, "IncludeTemporalData", Ложь));
		
	настройкиВыполнения.Вставить("ИерархияПолей", 					ПолучитьИерархиюПолейЗапроса(настройкиВыполнения, имяМетаданных));
	
	Возврат настройкиВыполнения;
КонецФункции

Функция ПолучитьТипИерархииСвойствИзНастроек(настройкиЗапроса)
	типИерархии = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиЗапроса, "PropertiesHierarchyType", "ОдинУровень");
		
	Если типИерархии = "SingleLevel" Или типИерархии = "ОдинУровень" Тогда
		Возврат "ОдинУровень";	
	КонецЕсли;
	
	Если типИерархии = "Hierarchy"  Или типИерархии = "Иерархия" Тогда
		Возврат "Иерархия";	
	КонецЕсли;
	
	Возврат "ОдинУровень";
КонецФункции
Функция ПолучитьНастройкиАвтодобавленияПолей(настройкиЗапроса)
	настройкиАвтодобавления = Новый Структура(
		"СтандартныеРеквизиты, ПользовательскиеПоля, ТабличныеЧасти",
		Ложь,
		Ложь,
		Ложь
	);
	
	автодобавление = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиЗапроса, "FieldAutoinclusion", Неопределено);
	Если автодобавление = Неопределено Тогда
		Возврат настройкиАвтодобавления;
	КонецЕсли;
	
	настройкиАвтодобавления.Вставить("СтандартныеРеквизиты", 			автодобавление.DefaultFields 	= Истина);
	настройкиАвтодобавления.Вставить("ПользовательскиеПоля", 			автодобавление.CustomFields 	= Истина);
	настройкиАвтодобавления.Вставить("ТабличныеЧасти", 					автодобавление.Tables 	= Истина);
	
	Возврат настройкиАвтодобавления;
КонецФункции
#КонецОбласти

#Область Формирование_иерархии_полей_вывода
Функция ПолучитьИерархиюПолейЗапроса(настройкиВыполнения, имяМетаданных = Неопределено)
	узел = ПолучитьУзелИерархииЗапроса();
	
	таблицаПолей = Новый ТаблицаЗначений();
	таблицаПолей.Колонки.Добавить("Путь");	
	таблицаПолей.Колонки.Добавить("Поле");
	
	допПоля = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиВыполнения.НастройкиЗапроса, "Field", Неопределено);
	Если допПоля <> Неопределено Тогда
		Для Каждого поле Из допПоля Цикл
			стр = таблицаПолей.Добавить();
			стр.Путь = поле.Key;
			стр.Поле = Новый Структура("Key, Name", поле.Key, поле.Name);
		КонецЦикла;
	КонецЕсли;	
	
	Если ЗначениеЗаполнено(имяМетаданных) Тогда
		Если имяМетаданных = "Константы" Тогда
			Для Каждого текКонстанта Из метаданные.Константы Цикл
				стр = таблицаПолей.Добавить();
				стр.Путь = текКонстанта.Имя;
				стр.Поле = Новый Структура("Key, Name", текКонстанта.Имя, текКонстанта.Имя);
			КонецЦикла;
		Иначе
			текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(имяМетаданных);
			автодобавление 	= настройкиВыполнения.АвтодобавлениеПолей; 
			
			Если автодобавление.СтандартныеРеквизиты И brom_Метаданные_ПИ.ОбъектИмеетСтандартныеРеквизиты(имяМетаданных) Тогда
				Для Каждого реквизит Из текМетаданные.СтандартныеРеквизиты Цикл
					Если реквизит.Имя = "Ссылка" Тогда
						Продолжить;
					КонецЕсли;
					
					стр = таблицаПолей.Добавить();
					стр.Путь = реквизит.Имя;
					стр.Поле = Новый Структура("Key, Name", реквизит.Имя, реквизит.Имя);
				КонецЦикла;
			КонецЕсли;
			
			Если автодобавление.ПользовательскиеПоля И brom_Метаданные_ПИ.ОбъектИмеетРеквизиты(имяМетаданных) Тогда
				Для Каждого реквизит Из текМетаданные.Реквизиты Цикл
					стр = таблицаПолей.Добавить();
					стр.Путь = реквизит.Имя;
					стр.Поле = Новый Структура("Key, Name", реквизит.Имя, реквизит.Имя);
				КонецЦикла;
				общРеквизиты = brom_Метаданные_ПИ.ПолучитьОбщиеРеквизитыОбъекта(имяМетаданных);
				Для Каждого реквизит Из общРеквизиты Цикл
					стр = таблицаПолей.Добавить();
					стр.Путь = реквизит.Имя;
					стр.Поле = Новый Структура("Key, Name", реквизит.Имя, реквизит.Имя);
				КонецЦикла;
			КонецЕсли;
			
			Если автодобавление.ТабличныеЧасти И brom_Метаданные_ПИ.ОбъектИмеетТабличныеЧасти(имяМетаданных) Тогда
				Для Каждого реквизит Из текМетаданные.ТабличныеЧасти Цикл
					стр = таблицаПолей.Добавить();
					стр.Путь = реквизит.Имя;
					стр.Поле = Новый Структура("Key, Name", реквизит.Имя, реквизит.Имя);
				КонецЦикла
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	таблицаПолей.Сортировать("Путь");
	
	Для Каждого стр Из таблицаПолей Цикл
		ОбработатьПоле(стр.Поле, узел, настройкиВыполнения);
	КонецЦикла;
	
	Возврат узел;
КонецФункции
Функция ОбработатьПоле(поле, узел, настройкиВыполнения)
	типИерархии 		= настройкиВыполнения.ТипИерархииСвойств;
	добавлятьСвойства	= настройкиВыполнения.ДобавлятьПропущенныеПоля;
	
	Если типИерархии = "ОдинУровень" Тогда
		новУзел = ПолучитьУзелИерархииЗапроса();
		новУзел.Путь 			= поле.Key;
		новУзел.ЛокальноеИмя 	= brom_Утилиты.ПолучитьИмяПоляЗапроса(новУзел.Путь, поле.Name);
		новУзел.ГлобальноеИмя 	= новУзел.ЛокальноеИмя;
		
		узел.Поля[новУзел.ЛокальноеИмя] 	= новУзел;
		узел.ПоляМассивом.Добавить(новУзел);
	ИначеЕсли типИерархии = "Иерархия" Тогда
		путь 				= поле.Key;
		имяПоля 			= поле.Name;
		фрагментыПути 		= СтрРазделить(путь, ".");
		текУзел 			= узел;
		текФрагменты 		= Новый Массив();
		границафрагментов 	= фрагментыПути.ВГраница();
		
		текЛокИмя			= "";
		Для к = 0 По фрагментыПути.ВГраница() Цикл
			фрагмент = фрагментыПути[к];
			текФрагменты.Добавить(фрагмент);
			текЛокИмя = текЛокИмя + фрагмент;
			
			Если ЗначениеЗаполнено(текУзел.Поля[текЛокИмя]) Тогда
				текУзел 	= текУзел.Поля[текЛокИмя];
				текЛокИмя 	= "";
			Иначе
				Если к = границафрагментов Или добавлятьСвойства Тогда
					локальноеИмя = ?(к = границафрагментов И ЗначениеЗаполнено(имяПоля), имяПоля, текЛокИмя); 
					
					новУзел 				= ПолучитьУзелИерархииЗапроса();
					новУзел.Путь 			= СтрСоединить(текФрагменты, ".");
					новУзел.ЛокальноеИмя 	= локальноеИмя;
					новУзел.ГлобальноеИмя 	= brom_Утилиты.ПолучитьИмяПоляЗапроса(новУзел.Путь);
					
					текУзел.Поля[текЛокИмя] = новУзел;
					текУзел.ПоляМассивом.Добавить(новУзел);
					текУзел = новУзел;
					текЛокИмя = "";
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецФункции

Функция ПолучитьИерархиюПолейЗапросаИзТаблицы(таблица)
	узел = ПолучитьУзелИерархииЗапроса();
	
	таблицаПолей = Новый ТаблицаЗначений();
	таблицаПолей.Колонки.Добавить("Путь");	
	
	Для Каждого колонка Из таблица.Колонки Цикл
		стр = таблицаПолей.Добавить();
		стр.Путь = колонка.Имя;
	КонецЦикла;
	таблицаПолей.Сортировать("Путь");
	
	Для Каждого стр Из таблицаПолей Цикл
		новУзел = ПолучитьУзелИерархииЗапроса();
		новУзел.Путь = стр.Путь;
		новУзел.ЛокальноеИмя 	= стр.Путь;
		новУзел.ГлобальноеИмя 	= стр.Путь;
		
		узел.Поля[стр.Путь] 	= новУзел;
		узел.ПоляМассивом.Добавить(новУзел);
	КонецЦикла;
	
	Возврат узел;
КонецФункции

Функция ПолучитьУзелИерархииЗапроса()
	узел = Новый Структура();
	узел.Вставить("Путь");
	узел.Вставить("ЛокальноеИмя");
	узел.Вставить("ГлобальноеИмя");
	узел.Вставить("Поля", 			Новый Соответствие());
	узел.Вставить("ПоляМассивом", 	Новый Массив());
	
	Возврат узел;
КонецФункции
#КонецОбласти

#Область Прикладные_методы
#Область Получение_информации_о_системе
Функция ПолучитьИнформациюОСистеме() Экспорт
	инфо = Новый Структура();
	инфо.Вставить("Имя",				Метаданные.Имя);
	инфо.Вставить("Синоним",			Метаданные.Синоним);
	инфо.Вставить("Версия",				Метаданные.Версия);
	инфо.Вставить("Поставщик",			Метаданные.Поставщик);
	
	инфо.Вставить("РасширениеБром",		ПолучитьИнформациюОРасширении(Метаданные.WebСервисы.brom_api.РасширениеКонфигурации()));
	
	массивРасширений = Новый Массив();
	
	расширения 		= РасширенияКонфигурации.Получить();
	Для Каждого расширение Из расширения Цикл   
		массивРасширений.Добавить(ПолучитьИнформациюОРасширении(расширение));	
	КонецЦикла;
	
	инфо.Вставить("Расширения",			массивРасширений);
	
	Возврат ВЗначениеБром(инфо);
КонецФункции
Функция ПолучитьИнформациюОРасширении(расширение) Экспорт
	инфо = Новый Структура();
	
	инфо.Вставить("Имя",						расширение.Имя);
	инфо.Вставить("Синоним",					расширение.Синоним);
	инфо.Вставить("Версия",						расширение.Версия);
	инфо.Вставить("Активно",					расширение.Активно);
	инфо.Вставить("ХешСумма",					расширение.ХешСумма);
	инфо.Вставить("УникальныйИдентификатор",	расширение.УникальныйИдентификатор);
	
	Возврат инфо;
КонецФункции
#КонецОбласти

#Область Выполнение_запросов
Функция ПолучитьРезультатЗапроса(текстЗапроса, настройкиЗапроса) Экспорт
	настройкиВыполнения = ПолучитьНастройкиВыполнения(настройкиЗапроса);
	
	пз = Новый ПостроительЗапроса(текстЗапроса);
	ПрименитьНастройкиЗапроса(пз, настройкиВыполнения);
	
	пз.Выполнить();
	                          
	данные = пз.Результат.Выгрузить(настройкиВыполнения.ТипОбходаРезультатаЗапроса); 
	
	Возврат ВЗначениеБром(данные);
КонецФункции
Функция ПолучитьРезультатПакетаЗапросов(текстЗапроса, настройкиЗапроса) Экспорт
	настройкиВыполнения = ПолучитьНастройкиВыполнения(настройкиЗапроса);
	
	пз = Новый ПостроительЗапроса(текстЗапроса);	
	пз.ЗаполнитьНастройки();
	
	ПрименитьНастройкиЗапроса(пз, настройкиВыполнения);
	
	запрос = пз.ПолучитьЗапрос();
	
	результаты = ?(настройкиВыполнения.ВключениеПромежуточныхДанных, запрос.ВыполнитьПакетСПромежуточнымиДанными(), запрос.ВыполнитьПакет());
	
	массивДанных = Новый Массив(); 
	Для Каждого результат Из результаты Цикл
		данные = результат.Выгрузить(настройкиВыполнения.ТипОбходаРезультатаЗапроса);
		массивДанных.Добавить(данные);
	КонецЦикла;
	
	Возврат ВЗначениеБром(массивДанных);
КонецФункции
#КонецОбласти

#Область Выполнение_кода
Функция ВыполнитьКод(код, параметр) Экспорт
	текПараметр = ИзЗначенияБром(параметр);
	результат = ПолучитьРезультатВыполненияКода(код, текПараметр);
	Возврат ВЗначениеБром(результат, Строка(результат));
КонецФункции
Функция ПолучитьРезультатВыполненияКода(brom_ИсполняемыйКод, параметр)
	parameter	= параметр;
	результат 	= Неопределено;
	result		= Неопределено;
	
	Выполнить(brom_ИсполняемыйКод);
	
	Возврат ?(результат = Неопределено, result, результат);
КонецФункции

Функция ВыполнитьМетод(имяМодуля, имяМетода, параметры) Экспорт
	полноеИмяМетода = НРег(СокрЛП(?(ЗначениеЗаполнено(имяМодуля), имяМодуля + "." + имяМетода, имяМетода)));
	
	Если Не brom_API_ПИ.УдаленныйВызовМетодаРазрешен(полноеИмяМетода) Тогда
		ВызватьИсключение("Вызов метода ограничен настройками доступа.");	
	КонецЕсли;
	
	текПараметры = ИзЗначенияБром(параметры);
	
	результат = ПолучитьРезультатВыполненияМетода(имяМодуля, имяМетода, текПараметры);
	
	Возврат ВЗначениеБром(результат, Строка(результат));
КонецФункции
Функция ПолучитьРезультатВыполненияМетода(имяМодуля, имяМетода, параметры) Экспорт
	brom_результат = Неопределено;
		
	массивПараметрыСтр = Новый Массив();
	Для к = 0 По параметры.ВГраница() Цикл
		массивПараметрыСтр.Добавить("параметры[" + Формат(к, "ЧН=0; ЧГ=0") + "]");
	КонецЦикла;
	парметрыСтр = СтрСоединить(массивПараметрыСтр, ", ");
	
	полноеИмяМетода = ?(ЗначениеЗаполнено(имяМодуля), имяМодуля + "." + имяМетода, имяМетода);
		
	Попытка
		текстИсполнения = "brom_результат = " + полноеИмяМетода + "(" + парметрыСтр + ");";
		Выполнить(текстИсполнения);
		Возврат brom_результат;
	Исключение
		описаниеОшибки = ОписаниеОшибки();
		Если СтрНайти(описаниеОшибки, "Обращение к процедуре объекта как к функции (" + имяМетода + ")") <> 0
			Или СтрНайти(описаниеОшибки, "Object procedure called as function (" + имяМетода + ")") <> 0 Тогда // <- Это печально
			
			текстИсполнения = полноеИмяМетода + "(" + парметрыСтр + ");";
			Выполнить(текстИсполнения);
		Иначе
			ВызватьИсключение ОписаниеОшибки();
		КонецЕсли;
	КонецПопытки;
	//+
	
	//-
	Возврат Неопределено;
КонецФункции
#КонецОбласти

#Область Работа_с_параметрами_сеанса
Функция ПолучитьЗначениеПараметраСеанса(имяПараметра) Экспорт
	текМетаданные = Метаданные.ПараметрыСеанса.Найти(имяПараметра);
	Если текМетаданные = Неопределено Тогда
		ВызватьИсключение "Объект не найден. (ПараметрСеанса." + имяПараметра + ")";
	КонецЕсли;
	
	значение = ПараметрыСеанса[имяПараметра];
	Возврат ВЗначениеБром(значение, Строка(значение));	
КонецФункции
#КонецОбласти

#Область Работа_с_константами
Функция ПолучитьЗначениеКонстанты(имяКонстанты, настройкиЗапроса) Экспорт
	текМетаданные = Метаданные.Константы.Найти(имяКонстанты);
	Если текМетаданные = Неопределено Тогда
		ВызватьИсключение "Объект не найден. (Константа." + имяКонстанты + ")";
	КонецЕсли;
	
	настройкиВыполнения = ПолучитьНастройкиВыполнения(настройкиЗапроса);
	
	текстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
     	|	Табл.Значение КАК Значение,
      	|	ПРЕДСТАВЛЕНИЕ(Табл.Значение) КАК ЗначениеПредставление
      	|{ВЫБРАТЬ
      	|	Табл.Значение.* КАК Объект}
      	|ИЗ
      	|	Константа.ИмяКонстанты КАК Табл";
	
	
	текстЗапроса = СтрЗаменить(текстЗапроса, "Константа.ИмяКонстанты", "Константа." + имяКонстанты);
	
	пз = Новый ПостроительЗапроса(текстЗапроса);
	ПрименитьПоляЗапроса(пз, настройкиВыполнения, "Объект");
	
	пз.Выполнить();	
	данные = пз.Результат.Выбрать();
		
	Если данные.Следующий() Тогда
		свойство = ВЗначениеБром_ИзПоляДанных(данные, "Значение");
		ЗаполнитьСвойстваСущности(свойство, данные, настройкиВыполнения.ИерархияПолей);
		
		Возврат свойство;
	КонецЕсли;    
	
	ВызватьИсключение "Объект не найден. (Константа." + имяКонстанты + ")";	
КонецФункции
Функция ПолучитьЗначенияКонстант(настройкиЗапроса) Экспорт
	результат = СоздатьXDTOОбъект("ValueStruct");
	
	Если Метаданные.Константы.Количество() = 0 Тогда
		Возврат результат;
	КонецЕсли;
	
	настройкиВыполнения = ПолучитьНастройкиВыполнения(настройкиЗапроса, "Константы");
	
	массивПолей = Новый Массив();
	Для Каждого текКонстанта Из Метаданные.Константы Цикл
		массивПолей.Добавить("Табл." + текКонстанта.Имя + ".*");  
	КонецЦикла;
	текстВыборки = СтрСоединить(массивПолей, ", "); 
	
	текстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		 |	Неопределено КАК brom_Blank
		 |	{ВЫБРАТЬ ПоляВыборки}
		 |ИЗ
		 |	Константы КАК Табл";
	
	
	текстЗапроса = СтрЗаменить(текстЗапроса, "ПоляВыборки", текстВыборки);
	
	пз = Новый ПостроительЗапроса(текстЗапроса);
	ПрименитьПоляЗапроса(пз, настройкиВыполнения);
	
	пз.Выполнить();
	
	данные = пз.Результат.Выбрать();
	данные.Следующий();
	ЗаполнитьСвойстваСущности(результат, данные, настройкиВыполнения.ИерархияПолей);
	
	Возврат результат;	
КонецФункции
Функция УстановитьЗначениеКонстанты(имяКонстанты, значение) Экспорт
	текМетаданные = Метаданные.Константы.Найти(имяКонстанты);
	
	текЗначение = ИзЗначенияБром(значение);
	ГлобальныеКонстанты[имяКонстанты].Установить(текЗначение); 
	
	Возврат Истина;	
КонецФункции
#КонецОбласти

#Область Получение_объектов
Функция ПолучитьСписокОбъектов(типСущности, имяСущности, настройкиЗапроса) Экспорт
	имяМетаданных = типСущности + "." + имяСущности;
	настройкиВыполнения = ПолучитьНастройкиВыполнения(настройкиЗапроса, имяМетаданных);
	
	максКоличествоЗаписей = brom_Утилиты.СвйоствоОбъектаXDTO(настройкиЗапроса, "Limit", 0);
	
	пз = ПолучитьБазовыйПостроительЗапросаКОбъекту(имяМетаданных, максКоличествоЗаписей);
	ПрименитьНастройкиЗапроса(пз, настройкиВыполнения, "Объект");
	
	пз.Выполнить();	
	данные = пз.Результат.Выгрузить();
	
	результат = СоздатьXDTOОбъект("ValueArray");	
	Для Каждого стрДанных Из данные Цикл
		элемент = ВЗначениеБром_ИзПоляДанных(стрДанных, "brom_Ссылка");
		ЗаполнитьСвойстваСущности(элемент, стрДанных, настройкиВыполнения.ИерархияПолей);
		
		результат.Item.Добавить(элемент);
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Функция ПолучитьОбъект(данныеСсылки, настройкиЗапроса) Экспорт
	ссылка 			= ИзЗначенияБром(данныеСсылки);
	текМетаданные 	= ссылка.Метаданные();
	имяМетаданных	= текМетаданные.ПолноеИмя();
	
	настройкиВыполнения = ПолучитьНастройкиВыполнения(настройкиЗапроса, имяМетаданных);
	
	пз = ПолучитьБазовыйПостроительЗапросаКОбъекту(имяМетаданных, 1);
	элементотбора = пз.Отбор.Добавить("Объект", "ReferenceFilter");
	элементотбора.Использование		= Истина;
	элементотбора.ВидСравнения 		= ВидСравнения.Равно;
	элементотбора.Значение 			= ссылка;
	
	ПрименитьПоляЗапроса(пз, настройкиВыполнения, "Объект");
	
	пз.Выполнить();
	данные = пз.Результат.Выгрузить();
	
	Если данные.Количество() > 0 Тогда
		результатXDTO = ВЗначениеБром_ИзПоляДанных(данные[0], "brom_Ссылка");
		ЗаполнитьСвойстваСущности(результатXDTO, данные[0], настройкиВыполнения.ИерархияПолей);
		
		Возврат результатXDTO;
	КонецЕсли;
	
	ВызватьИсключение "Объект не найден. (" + Строка(ссылка) + ")";
КонецФункции

Функция ПолучитьБазовыйПостроительЗапросаКОбъекту(имяМетоданных, количествоЗаписей = Неопределено)
	текМетаданные = brom_Метаданные_ПИ.ПолучитьМетаданные(имяМетоданных);
	                                    
	текстЗапроса = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ X
		|	Табл.Ссылка КАК brom_Ссылка,
		|	ПРЕДСТАВЛЕНИЕССЫЛКИ(Табл.Ссылка) КАК brom_СсылкаПредставление
		|{ВЫБРАТЬ
		|	brom_Ссылка.* КАК Объект}
		|ИЗ
		|	ТипОбъекта.ИмяОбъекта КАК Табл
		|{ГДЕ
		|	Табл.Ссылка.* КАК Объект}
		|{УПОРЯДОЧИТЬ ПО
		|	brom_Ссылка.* КАК Объект}";
	текстЗапроса = СтрЗаменить(текстЗапроса, "ТипОбъекта.ИмяОбъекта", имяМетоданных);
	Если НЕ ЗначениеЗаполнено(количествоЗаписей) Тогда
		текстЗапроса = СтрЗаменить(текстЗапроса, "ПЕРВЫЕ X", "");
	Иначе
		текстЗапроса = СтрЗаменить(текстЗапроса, "ПЕРВЫЕ X", "ПЕРВЫЕ " + Формат(количествоЗаписей, "ЧРГ=' '; ЧН=0; ЧГ=0"));
	КонецЕсли;	
	                
	Возврат Новый ПостроительЗапроса(текстЗапроса); 
КонецФункции
#КонецОбласти

#Область Публикация_объектов
Функция ОпубликоватьОбъект(данныеОбъекта, настройки) Экспорт
	имяМетаданных = данныеОбъекта.Type;
	
	Ссылка = Неопределено;
	Если brom_Метаданные_ПИ.ЭтоПеречисление(имяМетаданных) Тогда
		ВызватьИсключение "Объекты типа ""Перечисление (Enum)"" не доступны для перезаписи.";
	ИначеЕсли brom_Метаданные_ПИ.ЭтоСправочник(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектСправочник(данныеОбъекта, настройки);
	ИначеЕсли brom_Метаданные_ПИ.ЭтоДокумент(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектДокумент(данныеОбъекта, настройки);
	ИначеЕсли brom_Метаданные_ПИ.ЭтоПланВидовХарактеристик(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектПВХ(данныеОбъекта, настройки);
	ИначеЕсли brom_Метаданные_ПИ.ЭтоПланСчетов(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектПланСчетов(данныеОбъекта, настройки);
	ИначеЕсли brom_Метаданные_ПИ.ЭтоПланВидовРасчета(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектПланВидовРасчета(данныеОбъекта, настройки);
	ИначеЕсли brom_Метаданные_ПИ.ЭтоБизнесПроцесс(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектБизнесПроцесс(данныеОбъекта, настройки);
	ИначеЕсли brom_Метаданные_ПИ.ЭтоЗадача(имяМетаданных) Тогда
		Ссылка = ОпубликоватьОбъектЗадача(данныеОбъекта, настройки);
	КонецЕсли;
	
	настройкиЗапроса = СоздатьXDTOОбъект("GetObject_Settings");
	настройкиЗапроса.FieldAutoinclusion = СоздатьXDTOОбъект("RequestFieldAutoinclusionSettings");
	настройкиЗапроса.FieldAutoinclusion.DefaultFields = Истина;
	настройкиЗапроса.FieldAutoinclusion.CustomFields = Истина;
	настройкиЗапроса.FieldAutoinclusion.Tables = Истина;
		
	Возврат ПолучитьОбъект(ВЗначениеБром(Ссылка), настройкиЗапроса);
КонецФункции
Функция ОпубликоватьОбъектСправочник(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	этоГруппа 	= свойства.Свойство("ЭтоГруппа") И свойства.ЭтоГруппа = Истина;
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	Если Не этоГруппа Тогда
		объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьЭлемент());
	Иначе
		объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьГруппу());
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(объект, свойства);	
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	объект.Записать();
	
	Возврат объект.Ссылка;
КонецФункции
Функция ОпубликоватьОбъектДокумент(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьДокумент());
	
	ЗаполнитьЗначенияСвойств(объект, свойства);
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Если объект.Дата = Дата(1,1,1) Тогда
		объект.Дата = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	режимЗаписи 		= РежимЗаписиДокумента.Запись;
	режиПроведения 		= РежимПроведенияДокумента.Неоперативный;
	Если настройки <> Неопределено Тогда
		режимЗаписи 	= ?(ЗначениеЗаполнено(настройки.DocumentWriteMode), РежимЗаписиДокумента[настройки.DocumentWriteMode], режимЗаписи);	
		режиПроведения 	= ?(ЗначениеЗаполнено(настройки.DocumentPostingMode), РежимПроведенияДокумента[настройки.DocumentPostingMode], режиПроведения);	
	КонецЕсли;
	
	объект.Записать(режимЗаписи, режиПроведения);
	
	Возврат объект.Ссылка;
КонецФункции
Функция ОпубликоватьОбъектПВХ(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	этоГруппа 	= свойства.Свойство("ЭтоГруппа") И свойства.ЭтоГруппа = Истина;
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	Если Не этоГруппа Тогда
		объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьЭлемент());
	Иначе
		объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьГруппу());
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(объект, свойства);
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	объект.Записать();
	
	Возврат объект.Ссылка;
КонецФункции
Функция ОпубликоватьОбъектПланСчетов(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьСчет());
	
	ЗаполнитьЗначенияСвойств(объект, свойства);
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	объект.Записать();
	
	Возврат объект.Ссылка;
КонецФункции
Функция ОпубликоватьОбъектПланВидовРасчета(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьВидРасчета());
	
	ЗаполнитьЗначенияСвойств(объект, свойства);
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	объект.Записать();
	
	Возврат объект.Ссылка;
КонецФункции
Функция ОпубликоватьОбъектБизнесПроцесс(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьБизнесПроцесс());
	
	ЗаполнитьЗначенияСвойств(объект, свойства);
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	объект.Записать();
	
	Возврат объект.Ссылка;
КонецФункции
Функция ОпубликоватьОбъектЗадача(данныеОбъекта, настройки)
	текМенеджер 	= brom_Метаданные_ПИ.ПолучитьМенеджер(данныеОбъекта.Type);
	текМетаданные 	= brom_Метаданные_ПИ.ПолучитьМетаданные(данныеОбъекта.Type);
	
	свойства 	= ИзЗначенияБром_Структура(данныеОбъекта);
	
	ссылка = текМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(данныеОбъекта.Value));
	объект = ?(ЗначениеЗаполнено(ссылка), ссылка.ПолучитьОбъект(), текМенеджер.СоздатьЗадачу());
	
	ЗаполнитьЗначенияСвойств(объект, свойства);
	ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки);
	
	Для Каждого таблЧасть Из текМетаданные.ТабличныеЧасти Цикл
		Если свойства.Свойство(таблЧасть.Имя) Тогда
			объект[таблЧасть.Имя].Загрузить(свойства[таблЧасть.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	объект.Записать();
	
	Возврат объект.Ссылка;
КонецФункции

Процедура ЗаполнитьНастройкиОбъектаПриПубликации(объект, настройки)
	Если настройки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если настройки.AdditionalProperties <> Неопределено Тогда
		допСвойства = ИзЗначенияБром(настройки.AdditionalProperties);
		Если ЗначениеЗаполнено(допСвойства) Тогда
			Для Каждого ключЗначение Из допСвойства Цикл
				объект.ДополнительныеСвойства.Вставить(ключЗначение.Ключ, ключЗначение.Значение); 
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если настройки.ExchangeLoadMode = Истина Тогда
		объект.ОбменДанными.Загрузка = Истина;
	КонецЕсли;
КонецПроцедуры
#КонецОбласти

#Область Удаление_объектов
Функция УдалитьОбъект(данныеСсылки) Экспорт
	ссылка = ИзЗначенияБром(данныеСсылки);
	Если ЗначениеЗаполнено(ссылка) Тогда
		объект = ссылка.ПолучитьОбъект();
		объект.Удалить();
	Иначе
		ВызватьИсключение "Не возможно удалить объект, т.к. передана пустая ссылка.";
	КонецЕсли;
		
	Возврат Истина;
КонецФункции
#КонецОбласти

#Область Получение_метаданных
Функция ПолучитьМетаданные(стрУзлы, размерПакета, индексПакета) Экспорт
	загружаемыеКоллекции = ЗагружаемыеКоллекцииМетаданных();
	
	деревоУзлов = brom_API_ПИ.СформироватьДеревоЗагружаемыхУзлов(стрУзлы);
	
	полноеКоличествоОбъектов = ПолучитьПолноеКоличествоОбъектовМетаданных(загружаемыеКоллекции);
	запрошенноеКоличествоОбъектов = ПолучитьЗапрошенноеКоличествоОбъектовМетаданных(деревоУзлов);
	
	индексПакета = ?(ЗначениеЗаполнено(индексПакета), индексПакета, 0);
	размерПакета = ?(ЗначениеЗаполнено(размерПакета), размерПакета, полноеКоличествоОбъектов);
	
	начИндекс = размерПакета * индексПакета;
	конИндекс = начИндекс + размерПакета - 1;
	конИндекс = ?(конИндекс < запрошенноеКоличествоОбъектов, конИндекс, запрошенноеКоличествоОбъектов - 1);
	
	метаданныеXDTO = СоздатьXDTOОбъект("MetadataApplication");
	метаданныеXDTO.Name 		= Метаданные.Имя;
	метаданныеXDTO.Title 		= Метаданные.Синоним;
	метаданныеXDTO.FullName 	= Метаданные.ПолноеИмя();
	
	метаданныеXDTO.TotalObjectsCount		= полноеКоличествоОбъектов;
	метаданныеXDTO.RequestedObjectsCount	= запрошенноеКоличествоОбъектов;
	метаданныеXDTO.PackSize					= размерПакета;
	метаданныеXDTO.PackIndex				= индексПакета;
	
	текИндекс = 0;
	Для Каждого текИмяКоллекции Из загружаемыеКоллекции Цикл		
		ЗаполнитьКоллекциюМетаданных(метаданныеXDTO, текИмяКоллекции, текИндекс, начИндекс, конИндекс, деревоУзлов, запрошенноеКоличествоОбъектов);
	КонецЦикла;
	
	Возврат метаданныеXDTO;
КонецФункции
Функция ЗагружаемыеКоллекцииМетаданных()
	коллекции = Новый Массив();
	коллекции.Добавить("ПараметрыСеанса");
	коллекции.Добавить("КритерииОтбора");
	коллекции.Добавить("Константы");
	коллекции.Добавить("Справочники");
	коллекции.Добавить("Документы");
	коллекции.Добавить("Перечисления");
	коллекции.Добавить("ПланыВидовХарактеристик");
	коллекции.Добавить("ПланыСчетов");
	коллекции.Добавить("ПланыВидовРасчета");
	коллекции.Добавить("БизнесПроцессы");
	коллекции.Добавить("Задачи");
	коллекции.Добавить("ЖурналыДокументов");
	коллекции.Добавить("Обработки");
	коллекции.Добавить("Отчеты");
	коллекции.Добавить("РегистрыСведений");
	коллекции.Добавить("РегистрыНакопления");
	коллекции.Добавить("РегистрыБухгалтерии");
	коллекции.Добавить("РегистрыРасчета");
	коллекции.Добавить("Последовательности");
	коллекции.Добавить("ОбщиеМодули");
	
	Возврат коллекции;
КонецФункции
Функция СформироватьДеревоЗагружаемыхУзлов(Знач стрУзлы) Экспорт
	стрУзлы = СокрЛП(стрУзлы);
	
	фрагменты = СтрРазделить(стрУзлы, ",", Ложь);
	Если фрагменты.Количество() = 0 Тогда
		фрагменты.Добавить("*");	
	КонецЕсли;
	
	общКоличествоЭлементов = 0;
	
	дерево = Новый Структура();
	Для Каждого фрагмент Из фрагменты Цикл
		ДополнитьДеревоЗагружаемыхУзлов(дерево, СокрЛП(фрагмент));
	КонецЦикла;
	
	Возврат дерево;
КонецФункции
Процедура ДополнитьДеревоЗагружаемыхУзлов(дерево, Знач стрУзел)
	фрагменты = СтрРазделить(стрУзел, ".");
	Если фрагменты.Количество() = 1 Тогда
		фрагменты.Добавить("*");	
	КонецЕсли;
	
	загружаемыеКоллекции = ЗагружаемыеКоллекцииМетаданных();
	
	Если фрагменты[0] = "*" Тогда
		Для Каждого загрКоллекция Из загружаемыеКоллекции Цикл
			ДополнитьДеревоЗагружаемыхУзлов(дерево, загрКоллекция + ".*");
		КонецЦикла;
		Возврат;
	КонецЕсли;
	
	текКоллекция = фрагменты[0];
	индекс = загружаемыеКоллекции.Найти(текКоллекция);
	Если индекс = Неопределено Тогда
		ВызватьИсключение "Коллекция """ + текКоллекция + """ не может быть загружена."
	КонецЕсли;
	текКоллекция 	= загружаемыеКоллекции[индекс];
	узелКоллекции 	= Метаданные[текКоллекция];
	
	текЭлемент = фрагменты[1];
	Если текЭлемент = "*" Тогда
		
		Для Каждого текУзел Из узелКоллекции Цикл
			ДополнитьДеревоЗагружаемыхУзлов(дерево, текКоллекция + "." + текУзел.Имя);
		КонецЦикла;	
		Возврат;
	КонецЕсли;
	
	текУзел = узелКоллекции.Найти(текЭлемент);
	Если текУзел = Неопределено Тогда
		ВызватьИсключение "Объект метаданных """ + текЭлемент + """ не найден в коллекции """ + текКоллекция + """";
	КонецЕсли;
	
	Если Не дерево.Свойство(текКоллекция) Тогда
		дерево.Вставить(текКоллекция, Новый Массив());
	КонецЕсли;
	текМассив = дерево[текКоллекция];
	Если текМассив.Найти(текУзел.Имя) = Неопределено Тогда
		текМассив.Добавить(текУзел.Имя);
	КонецЕсли;
КонецПроцедуры
Функция ПолучитьПолноеКоличествоОбъектовМетаданных(загружаемыеКоллекции)
	результат = 0;
	Для Каждого текИмяКоллекции Из загружаемыеКоллекции Цикл
		текУзелКоллекции = Метаданные[текИмяКоллекции];
		результат = результат + текУзелКоллекции.Количество();
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Функция ПолучитьЗапрошенноеКоличествоОбъектовМетаданных(деревоУзлов)
	результат = 0;
	Для Каждого ключЗначение Из деревоУзлов Цикл
		результат = результат + ключЗначение.Значение.Количество();
	КонецЦикла;
	
	Возврат результат;
КонецФункции
Процедура ЗаполнитьКоллекциюМетаданных(метаданныеXDTO, текИмяКоллекции, текИндекс, начИндекс, конИндекс, деревоУзлов, запрошенноеКоличествоОбъектов)
	// Пропускаем коллекцию, если индекс слижком большой
	Если текИндекс > конИндекс Тогда
		Возврат;
	КонецЕсли;
	
	Если Не деревоУзлов.Свойство(текИмяКоллекции) Тогда
		Возврат;	
	КонецЕсли;
	объектыКоллекцииДерева = деревоУзлов[текИмяКоллекции];
	колвоОбъектовДерева = объектыКоллекцииДерева.Количество();
	Если колвоОбъектовДерева = 0 Тогда
		Возврат;
	КонецЕсли;
	
	текУзелКоллекции 		= Метаданные[текИмяКоллекции];
	полныйРазмерКоллекции 	= текУзелКоллекции.Количество();
	
	// Пропускаем коллекцию, если индекс слижком мал
	Если текИндекс + колвоОбъектовДерева <= начИндекс Тогда
		текИндекс = текИндекс + колвоОбъектовДерева;
		Возврат;
	КонецЕсли;	
	
	начИндексМассива = 0;
	Если текИндекс < начИндекс Тогда
		начИндексМассива = начИндекс - текИндекс;
		текИндекс = текИндекс + начИндексМассива;
	КонецЕсли;
	
	коллекцияXDTO = СоздатьXDTOОбъект("MetadataCollection");
	коллекцияXDTO.Name						= текИмяКоллекции;
	коллекцияXDTO.TotalObjectsCount 		= полныйРазмерКоллекции;
	коллекцияXDTO.RequestedObjectsCount 	= объектыКоллекцииДерева.Количество();
	
	загружено = 0;
	Для текИндексМассива = начИндексМассива По колвоОбъектовДерева - 1 Цикл
		Если текИндекс > конИндекс Тогда
			Прервать;
		КонецЕсли;
		текИмяОбъекта = объектыКоллекцииДерева[текИндексМассива];
		ЗаполнитьМетаданныеОбъектаКоллекции(текУзелКоллекции, коллекцияXDTO, текИмяОбъекта);
		загружено = загружено + 1;
		текИндекс = текИндекс + 1;
	КонецЦикла;
	
	коллекцияXDTO.PackObjectsCount = загружено;
	
	метаданныеXDTO.Collection.Добавить(коллекцияXDTO);
КонецПроцедуры
Процедура ЗаполнитьМетаданныеОбъектаКоллекции(узелКоллекции, коллекцияXDTO, имяОбъекта)
	узелОбъекта = узелКоллекции[имяОбъекта];
	
	Если 		коллекцияXDTO.Name = "Справочники" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Документы" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Перечисления" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "ПланыВидовХарактеристик" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "ПланыСчетов" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "ПланыВидовРасчета" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "БизнесПроцессы" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Задачи" Тогда
		объектXDTO = ПолучитьМетаданныеСсылочногоОбъекта(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "ЖурналыДокументов" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "ПараметрыСеанса" Тогда
		объектXDTO = ПолучитьМетаданныеРеквизита(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "КритерииОтбора" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Константы" Тогда
		объектXDTO = ПолучитьМетаданныеКонстанты(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Обработки" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Отчеты" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "РегистрыСведений" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "РегистрыНакопления" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "РегистрыБухгалтерии" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "РегистрыРасчета" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "Последовательности" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	ИначеЕсли 	коллекцияXDTO.Name = "ОбщиеМодули" Тогда
		объектXDTO = ПолучитьМетаданныеМодуля(узелОбъекта);
	КонецЕсли;
	
	коллекцияXDTO.Item.Добавить(объектXDTO);
КонецПроцедуры

Функция ПолучитьМетаданныеСсылочногоОбъекта(метаОбъект)
	объектXDTO = СоздатьXDTOОбъект("MetadataObject");
	объектXDTO.Name 			= метаОбъект.Имя;
	объектXDTO.Title 			= метаОбъект.Синоним;
	объектXDTO.FullName 		= метаОбъект.ПолноеИмя();
	объектXDTO.CollectionType 	= brom_Метаданные_ПИ.ПолучитьТипКоллекцииИзПолногоИмени(метаОбъект.ПолноеИмя()); 
	
	Если brom_Утилиты.СвойствоУстановлено(метаОбъект, "СтандартныеРеквизиты") Тогда
		Для Каждого текРеквизит Из метаОбъект.СтандартныеРеквизиты Цикл
			объектXDTO.Attribute.Добавить(ПолучитьМетаданныеРеквизита(текРеквизит));	
		КонецЦикла;
	КонецЕсли;
	
	Если brom_Утилиты.СвойствоУстановлено(метаОбъект, "Реквизиты") Тогда
		Для Каждого текРеквизит Из метаОбъект.Реквизиты Цикл
			Если текРеквизит.Имя = "Ссылка" тогда
				продолжить;
			КонецЕсли;
			
			объектXDTO.Attribute.Добавить(ПолучитьМетаданныеРеквизита(текРеквизит));	
		КонецЦикла;
		
		общРеквизиты = brom_Метаданные_ПИ.ПолучитьОбщиеРеквизитыОбъекта(объектXDTO.FullName);
		Для Каждого текРеквизит Из общРеквизиты Цикл	
			объектXDTO.Attribute.Добавить(ПолучитьМетаданныеРеквизита(текРеквизит));	
		КонецЦикла;
	КонецЕсли;
	
	Если brom_Утилиты.СвойствоУстановлено(метаОбъект, "СтандартныеТабличныеЧасти") Тогда
		Для Каждого текТабл Из метаОбъект.СтандартныеТабличныеЧасти Цикл
			объектXDTO.TableSection.Добавить(ПолучитьМетаданныеТабличнойЧасти(текТабл, Истина, Ложь));	
		КонецЦикла;
	КонецЕсли;
	
	Если brom_Утилиты.СвойствоУстановлено(метаОбъект, "ТабличныеЧасти") Тогда
		Для Каждого текТабл Из метаОбъект.ТабличныеЧасти Цикл
			объектXDTO.TableSection.Добавить(ПолучитьМетаданныеТабличнойЧасти(текТабл, Истина, Истина));	
		КонецЦикла;
	КонецЕсли;
	
	предопределенные = brom_Метаданные_ПИ.ПолучитьПредопределенныеЗначения(объектXDTO.FullName);
	объектXDTO.Predefined = ?(ЗначениеЗаполнено(предопределенные), ВЗначениеБром(предопределенные), Неопределено);
	
	Возврат объектXDTO;
КонецФункции
Функция ПолучитьМетаданныеМодуля(метаОбъект)
	объектXDTO = СоздатьXDTOОбъект("MetadataModule");
	объектXDTO.Name 			= метаОбъект.Имя;
	объектXDTO.Title 			= метаОбъект.Синоним;
	объектXDTO.FullName 		= метаОбъект.ПолноеИмя();
	
	Возврат объектXDTO;
КонецФункции
Функция ПолучитьМетаданныеРеквизита(метаРеквизит)
	реквизитXDTO 			= СоздатьXDTOОбъект("MetadataAttribute");
	реквизитXDTO.Name 		= метаРеквизит.Имя;
	реквизитXDTO.Title 		= метаРеквизит.Синоним;
	
	Возврат реквизитXDTO;
КонецФункции
Функция ПолучитьМетаданныеПараметраСеанса(метаПарамСеанса)
	объектXDTO 			= ПолучитьМетаданныеРеквизита(метаПарамСеанса);
	объектXDTO.FullName = метаПарамСеанса.ПолноеИмя();
	
	Возврат объектXDTO;
КонецФункции
Функция ПолучитьМетаданныеКонстанты(метаКонстанта)
	константаXDTO 			= ПолучитьМетаданныеРеквизита(метаКонстанта);
	константаXDTO.FullName 	= метаКонстанта.ПолноеИмя();
	
	Возврат константаXDTO;
КонецФункции
Функция ПолучитьМетаданныеТабличнойЧасти(метаТабл, стдРеквизиты = Ложь, реквизиты = Ложь)
	таблXDTO 		= СоздатьXDTOОбъект("MetadataTableSection");
	таблXDTO.Name 	= метаТабл.Имя;
	таблXDTO.Title 	= метаТабл.Синоним;
	
	Если стдРеквизиты Тогда
		Для Каждого текРеквизит Из метаТабл.СтандартныеРеквизиты Цикл
			таблXDTO.Attribute.Добавить(ПолучитьМетаданныеРеквизита(текРеквизит));	
		КонецЦикла;
	КонецЕсли;
	
	Если реквизиты Тогда
		Для Каждого текРеквизит Из метаТабл.Реквизиты Цикл
			таблXDTO.Attribute.Добавить(ПолучитьМетаданныеРеквизита(текРеквизит));	
		КонецЦикла;
	КонецЕсли;
	
	Возврат таблXDTO;
КонецФункции

Функция ПолучитьИменаПодчиненныхУзловМетаданных(стрРодители) Экспорт
	результат = Новый Соответствие();
	
	фрагменты = СтрРазделить(стрРодители, ",", Ложь);
	Для Каждого стрРодитель Из фрагменты Цикл
		УказатьИменаРодительскогоУзла(результат, СокрЛП(стрРодитель));	
	КонецЦикла;
	
	Возврат  ВЗначениеБром(результат);
КонецФункции
Процедура УказатьИменаРодительскогоУзла(результат, Знач стрРодитель)
	стрРодитель = СокрЛП(стрРодитель);
	
	текУзел = Метаданные;
	фрагменты = СтрРазделить(стрРодитель, ".", Ложь);
	Для Каждого фрагмент Из фрагменты Цикл
		текУзел = текУзел[фрагмент];
	КонецЦикла;
	
	Если ТипЗнч(текУзел) <> Тип("КоллекцияОбъектовМетаданных") Тогда
		ВызватьИсключение "Узел методанных """ + стрРодитель + """ не явялется коллекцией объектов методанных.";
	КонецЕсли;
	
	именаУзлов = Новый Массив();
	Для Каждого подчиненныйУзел Из текУзел Цикл
		именаУзлов.Добавить(подчиненныйУзел.Имя);	
	КонецЦикла;
	
	результат.Вставить(стрРодитель, именаУзлов);
КонецПроцедуры
#КонецОбласти
#КонецОбласти